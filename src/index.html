<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Body Simulation with Taichi.js</title>
    <style>
        canvas {
            display: block;
            margin: 0;
            background: black;
            width: 100%;
        }

        .circle {
            width: 100px;
            height: 100px;
            background-color: red;
            border-radius: 50%;
            /* Makes it a circle */
        }
    </style>
    <script src="https://unpkg.com/taichi.js/dist/taichi.umd.js"></script>
    <script>
        let main = async () => {
            await ti.init();
            let N = 128;
            let liveness = ti.field(ti.i32, [N, N]);
            let numNeighbors = ti.field(ti.i32, [N, N]);
            ti.addToKernelScope({ N, liveness, numNeighbors });
            let init = ti.kernel(() => {
                for (let I of ti.ndrange(N, N)) {
                    liveness[I] = 0;
                    let f = ti.random();
                    if (f < 0.2) {
                        liveness[I] = 1;
                    }
                }
            });
            await init();
            let countNeighbors = ti.kernel(() => {
                for (let I of ti.ndrange(N, N)) {
                    let neighbors = 0;
                    for (let delta of ti.ndrange(3, 3)) {
                        let J = (I + delta - 1) % N;
                        if ((J.x != I.x || J.y != I.y) && liveness[J] == 1) {
                            neighbors = neighbors + 1;
                        }
                    }
                    numNeighbors[I] = neighbors;
                }
            });
            let updateLiveness = ti.kernel(() => {
                for (let I of ti.ndrange(N, N)) {
                    let neighbors = numNeighbors[I];
                    if (liveness[I] == 1) {
                        if (neighbors < 2 || neighbors > 3) {
                            liveness[I] = 0;
                        }
                    } else {
                        if (neighbors == 3) {
                            liveness[I] = 1;
                        }
                    }
                }
            });
            let htmlCanvas = document.getElementById('result_canvas');
            htmlCanvas.width = 512;
            htmlCanvas.height = 512;
            let renderTarget = ti.canvasTexture(htmlCanvas);
            let vertices = ti.field(ti.types.vector(ti.f32, 2), [6]);
            await vertices.fromArray([
                [-1, -1],
                [1, -1],
                [-1, 1],
                [1, -1],
                [1, 1],
                [-1, 1],
            ]);
            ti.addToKernelScope({ vertices, renderTarget });
            let render = ti.kernel(() => {
                ti.clearColor(renderTarget, [0.0, 0.0, 0.0, 1.0]);
                for (let v of ti.inputVertices(vertices)) {
                    ti.outputPosition([v.x, v.y, 0.0, 1.0]);
                    ti.outputVertex(v);
                }
                for (let f of ti.inputFragments()) {
                    let coord = (f + 1) / 2.0;
                    let cellIndex = ti.i32(coord * (liveness.dimensions - 1));
                    let live = ti.f32(liveness[cellIndex]);
                    ti.outputColor(renderTarget, [live, live, live, 1.0]);
                }
            });
            async function frame() {
                countNeighbors();
                updateLiveness();
                await render();
                requestAnimationFrame(frame);
            }
            await frame();
        };
        main();
    </script>
</head>

<body>
    <canvas id="result_canvas"></canvas>
    <div class="circle" id="first"></div>
    <div class="circle" id="second"></div>
    <div class="circle" id="third"></div>
</body>

</html>